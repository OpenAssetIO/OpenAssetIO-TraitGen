{%- if copyrightOwner -%}
// SPDX-License-Identifier: {{ spdxLicenseIdentifier }}
// Copyright {{ copyrightDate }} {{ copyrightOwner }}
{%- endif %}
// WARNING: This file is auto-generated by openassetio-traitgen, do not edit.

#pragma once

#include <optional>
#include <stdexcept>
#include <utility>

#include <openassetio/trait/TraitsData.hpp>
#include <openassetio/trait/collection.hpp>
#include <openassetio/trait/property.hpp>

namespace openassetio_abi = openassetio::{{ openassetio_abi_version }};

namespace {{ package.id | to_cpp_namespace_name }} {
inline namespace {{ traitgen_abi_version }} {
namespace traits::{{ namespace.id | to_cpp_namespace_name }} {

namespace property = openassetio_abi::trait::property;

{%- for trait in versions %}
{% set classname = trait.name | to_cpp_class_name ~ 'Trait_v' ~ trait.version -%}
/**
 * {{ trait.description |  wordwrap(69, wrapstring="\n* ") | indent(1) }}
{%- if trait.usage %}
 * Usage: {{ trait.usage | join(', ') }}
{%- endif %}
{%- if trait.deprecated %}
 *
 * @deprecated This trait is flagged for future removal.
{%- endif %}
 */
class
{%- if trait.deprecated %}
[[deprecated("The '{{ trait.id }}' trait is deprecated.")]]
{% endif %} {{ classname }} {
public:
  static inline const openassetio_abi::trait::TraitId kId = "{{ trait.id }}";

  /**
   * Construct this trait view, wrapping the given TraitsData instance.
   */
  explicit {{ classname }}(openassetio_abi::trait::TraitsDataPtr traitsData)
    : traitsData_{std::move(traitsData)}
  {}

  /**
   * Check whether a TraitsData instance has this trait set.
   *
   * @param traitsData Data to check.
   * @return `true` if the given TraitsData instance has this trait
   * set, `false` otherwise.
   */
  [[nodiscard]] static bool isImbuedTo(const openassetio::trait::TraitsDataPtr& traitsData) {
    return traitsData->hasTrait(kId);
  }

  /**
   * Check whether the TraitsData instance this trait has been
   * constructed with has this trait set.
   *
   * @return `true` if the underlying TraitsData instance has this trait
   * set, `false` otherwise.
   **/
  [[nodiscard]] bool isImbued() const { return isImbuedTo(traitsData_); }

  /**
   * Applies this trait to the wrapped TraitsData instance.
   *
   * If the instance already has this trait, it is a no-op.
   **/
  void imbue() const { imbueTo(traitsData_); }

  /**
   * Applies this trait to the supplied TraitsData instance.
   *
   * If the instance already has this trait, it is a no-op.
   *
   * @param traitsData The instance to apply the trait to.
   **/
  static void imbueTo(const openassetio::trait::TraitsDataPtr& traitsData) { traitsData->addTrait(kId); }

  {%- if trait.properties -%}
    {%- for property in trait.properties -%}
       {%- set VarMethodName = property.id | to_cpp_var_accessor_name -%}
       {%- set VarName = property.id | to_cpp_var_name -%}
       {%- set VarType = property.type | to_cpp_type %}

  /**
   * Sets the {{ property.id }} property.
   *
   * {{ property.description |  wordwrap(69, wrapstring="\n* ") | indent(5) }}
   */
  void set{{ VarMethodName }}({{ VarType }} {{ VarName }}) {
    {%- if (property.type | is_moveable_type) %}
    traitsData_->setTraitProperty(kId, property::Key{"{{ property.id }}"}, std::move({{ VarName }}));
    {%- else %}
    traitsData_->setTraitProperty(kId, property::Key{"{{ property.id }}"}, {{ VarName }});
    {%- endif %}
  }

  /**
   * Gets the value of the {{ property.id }} property or the supplied
   * default.
   *
   * {{ property.description |  wordwrap(69, wrapstring="\n* ") | indent(4) }}
   */
  [[nodiscard]] {{ VarType }} get{{ VarMethodName }}(const {{ VarType }}& defaultValue) const {
    if (property::Value value; traitsData_->getTraitProperty(&value, kId, "{{ property.id }}")) {
      if (auto* maybeOut = std::get_if<{{ VarType }}>(&value)) {
        return *maybeOut;
      }
    }
    return defaultValue;
  }

  /**
   * Gets the value of the {{ property.id }} property. Returns an empty
   * optional if not found or is of an unexpected type.
   *
   * {{ property.description |  wordwrap(69, wrapstring="\n* ") | indent(4) }}
   */
  [[nodiscard]] std::optional<{{ VarType }}> get{{ VarMethodName }}() const {
    if (property::Value value; traitsData_->getTraitProperty(&value, kId, "{{ property.id }}")) {
      if (auto* maybeOut = std::get_if<{{ VarType }}>(&value)) {
        return *maybeOut;
      }
      throw std::runtime_error{"Invalid stored value type: should be '{{ VarType }}'."};
    }
    return std::optional<{{VarType}}>{};
  }
    {%-  endfor %}
  {%- endif %}

private:
  openassetio_abi::trait::TraitsDataPtr traitsData_;
};

{% endfor %}

{%- set trait = versions[0] %}
{%- set base_classname = trait.name | to_cpp_class_name ~ "Trait" %}
/**
 * {{ trait.description |  wordwrap(69, wrapstring="\n* ") | indent(1) }}
{%- if trait.usage %}
 * Usage: {{ trait.usage | join(', ') }}
{%- endif %}
 *
 * @deprecated Unversioned trait view classes are deprecated, please use
 * {{ base_classname }}_v1 explicitly.
 */
class
[[deprecated("Unversioned trait view classes are deprecated, please use {{ base_classname }}_v1 explicitly.")]]
{{ base_classname }} : public {{ base_classname }}_v1 {
public:
using {{ base_classname }}_v1::{{ base_classname }}_v1;
};
}  // namespace traits::{{ namespace.id | to_cpp_namespace_name }}
}  // namespace {{ traitgen_abi_version }}
}  // namespace {{ package.id | to_cpp_namespace_name }}
